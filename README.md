> [!NOTE]
> Настоящий проект был разработан в демонстративных целях в соответствии с техническим заданием[^1]
> 
> Многие упреждения в абстракциях представляются демонстративными целями и не имеют ничего общего с бизнес-проектом, пока и поскольку многие требования остаются неизвестными, что может приводить к дырявым абстракциям впоследствии упреждения.

# Содержание
1. [Комментарии к ТЗ](#t3-comments)
2. [Стек разработки](#dev-stack)
3. [Спецификация проектов](#projects-spec)
	1. [Доменный уровень](#projects-spec-domain)
	2. [Прикладной уровень](#projects-spec-application)
	3. [Инфраструктурный уровень](#projects-spec-infrastructure)
5. [Сборка и развертка](#build-deploy)
	1. [.NET](#build-deploy-dotnet)
	2. [Docker](#build-deploy-docker)
6. [Тестирование](#test)
7. [Заключение](#conclusion)
8. [Комментарии разработчика](#dev-comments)


<a name="t3-comments"></a>
## Комментарии к ТЗ
> Ограничение на количество записей в хранилище (100) является бизнес-требованием или же это ограничение чисто техническое?

Бизнес-требование <sup>© Кирилл Погарцев</sup>

> Является ли insertDateTime бизнес-требованием?

Техническое требование <sup>© Кирилл Погарцев</sup>


<a name="dev-stack"></a>
## Стек разработки
* [Visual Studio 2022](https://visualstudio.microsoft.com/vs/) - IDE
* NET 8, [WEB SDK](https://github.com/dotnet/aspnetcore) - WEB презентор
* [Swagger](https://github.com/swagger-api) - тестирование WEB запросов
* [NHibernate](https://github.com/nhibernate/) - ORM
* [Sqlite](https://github.com/sqlite/sqlite) - БД
* [Fluent Validation](https://github.com/FluentValidation/) - валидация контрактов
* [Mapster](https://github.com/MapsterMapper/) - отображение контракт-сущность, сущность-контракт
* [Redis](https://github.com/redis/redis) - кэш второго уровня
* [Seq](https://datalust.co/seq) - логирование
* [OpenTelemetry](https://github.com/open-telemetry) - логирование через OTLP протокол для Seq
* [NUnit](https://github.com/nunit/nunit), [NSubstitute](https://github.com/nsubstitute/NSubstitute) - тестирование
* [Roslyn](https://github.com/dotnet/roslyn) - посткомпиляция, реализация AOP

<a name="projects-spec"></a>
## Спецификация проектов

<a name="projects-spec-domain"></a>
### Доменный уровень

| Проект  | Описание |
| ------------- | ------------- |
| T3.Domain.Shared  | Содержит абстрактные сущности предметной области |
| T3.Transactions.Core  | Домен транзакций |

<a name="projects-spec-application"></a>
### Прикладной уровень

| Проект  | Описание |
| ------------- | ------------- |
| T3.API.Shared  | Содержит абстракции для прикладного уровня |
| T3.Transactions.API  | Реализация случаев использования для транзакций |

<a name="projects-spec-infrastructure"></a>
### Инфраструктурный уровень

| Проект  | Описание |
| ------------- | ------------- |
| T3.Web  | Презентор HTTP REST |
| T3.Data  | Детали хранения данных |
| T3.Logger  | Логирование |
| T3.Data.AuditableBuilder | Автогенерация кода для реализации AOP генерации аудит-репозиториев |
| T3.Transactions.Domain.Test | Модульные тесты доменного уровня |

<a name="build-deploy"></a>
## Сборка и развертка

Запустить
```
git clone https://github.com/toneysix/T3.git
cd T3
```

**Конфигурации сборки**
| Проект  | Константы | Конфигурации | Профили | Примечание |
| ------------- | ------------- | ------------- | ------------- | ------------- |
| T3.Web | - | Debug, Release | http, Container (dockerfile), IIS | - |
| docker-compose | DOCKER_BUILD | Debug, Release  | - | <ul><li>REDIS+</li><li>SEQ+</li></ul> |
| T3.Transaction.Domain.Test | - | Debug, Release  | - | - |

<a name="build-deploy-dotnet"></a>
### .NET

Запустить ```dotnet run --project src/T3.Web```

<a name="build-deploy-docker"></a>
### Docker

> [!TIP]
> **Для Windows 10** c пакетом обновления [KB5003791](https://support.microsoft.com/en-us/topic/kb5003791-update-to-windows-10-version-21h2-by-using-an-enablement-package-8bc077be-18d7-4aac-81ce-6f6dad2cd384) версии и выше необходимо скачать и установить [Docker Desktop](https://docs.docker.com/desktop/setup/install/windows-install/)

> [!TIP]
> **Linux**</br>
>```
>curl -fsSL https://get.docker.com -o get-docker.sh
>sudo sh ./get-docker.sh --dry-run
>```

Запустить ```docker-compose up --build --force-recreate```

<a name="test"></a>
## Тестирование

Выполните следующую команду для запуска всех существующих тестов в решении

```dotnet test T3.sln```

**Приложение**
| Инстанс | Хост | Порт | Протокол | Полный адрес | Примечание |
| ------------- | ------------- | ------------- | ------------- | ------------- | ------------- |
| Web | localhost | 9000 | HTTP | [http://localhost:9000/swagger/index.html](http://localhost:6060/swagger/index.html)  | - |
| Seq | localhost | 6060 | HTTP | [http://localhost:6060](http://localhost:6060) | Только [Docker Compose Сборка](#build-deploy-docker) |
| Redis | localhost | 2020 | RESP | redis://localhost:2020 | Только [Docker Compose Сборка](#build-deploy-docker) |


<a name="conclusion"></a>
## Заключение

В настоящем проекте были применены различные практики, которые не оправданы в условиях ограниченного знания предметной области, в частности, преждевременные абстракции, что могут привести в дальнейшем к дырявым абстракциям, целью таких упреждений была демонстрация наличия соответствующих компетенций в контексте разработки сложных систем. Некоторые моменты не были достаточно проработаны, к примеру, множественная обработка ошибок, автовалидация и маппинг в слое прикладного уровня.

<a name="dev-comments"></a>
## Комментарии разработчика

* До сих пор осталось неясно требование относительно сущности транзакции, представляющаяся `record`, а не `class`, был ли это DTO. В любом случае для сущностей я бы не использорвал рекорды, так как они генерируют под капотом очень важные методы, которые требуется переопределять вручную. В связи с этим ограничением было отключено свойство ленивой загрузки в ORM, хотя и для данной сущности она не потребуется.
* Свойства сущности транзакции такие, как сумма проведения, можно было обернуть в `ValueObject`
* Сущность транзакции в целом получилась анемичной, это связано с ограничениями сеттеров `init`
* В связи с использованием ORM есть моменты, связанные с определенными нарушениями сущностей, в частности, требование виртуальных свойств, в целом можно было использовать адаптеры между представлением сущности в базе и в доменной области, это компромисс
* Проект был разбит по уровням для демонстрации отсутствия нарушения архитектурных границ
* Обертка над ORM. Да, сама ORM является абстракцией над БД, однако, это довольно холиварная тема, и я все же предпочитаю не использовать БД контексты, единицы развертывания, предоставляемые из самой ORM, чтобы тащить за собой пакеты ORM (NHibernate не включает пакеты абстракции), отсюда также вытекает предпочтение в использовании паттерна Repository. Вот что говорит Роберт Мартин в своей книге ‭«Чистая Архитектура» об этом 
> Where should such ORM systems reside? In the database layer of course. 
Indeed, ORMs form another kind of Humble Object boundary between the gateway interfaces and the database[^2]
* Использование Roslyn для автогенерации кода не является оптимальным решением в связи с его многословностью, что вынудило меня написать некоторые обертки, упрощающие генерацию кода, в целом была опция сгенерировать динамическую сборку посредством рефлексии
* Поскольку аудит-информация является техническим требованием, было решено вынести эту деталь в прикладной уровень приложения
* Problem Details реализован не полностью, в частности,он не обрабатывает ошибки уровня домена, такие как сущность не найдена, выдавая 404 ответ. Ошибки домена и валидации будут представлены как ошибка 400
* Решение по созданию сервиса уровня домена было принципиальным в связи с наличием определенных доменных ограничений, которые не укладывались в рамках прикладнго уровня приложения с использованием репозитория напрямую

[^1]: [Техническое задание Т3](docs/T3.pdf)
[^2]: [Robert Martin, Clean Architecture, p. 204](https://github.com/ropalma/ICMC-USP/blob/master/Book%20-%20Clean%20Architecture%20-%20Robert%20Cecil%20Martin.pdf)